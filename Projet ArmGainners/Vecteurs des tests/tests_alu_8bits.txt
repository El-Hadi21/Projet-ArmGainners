# ==============================
# TEST COMPLET DES FLAGS (NZCV)
# ==============================
# port_name[port_size]
A[32] B[32] Shift[5] CarryIn[1] Codop[4] S[32] Flags[4]

# --------------------------------------------------
# Test 1 : AND (0000) - Logique
# 0xAAAA... & 0x5555... = 0
# Flags = 0100 (N=0, Z=1, C=0, V=0)
11111111111111110000000000000000 10101010101010100101010101010101 00000 0 0000 10101010101010100000000000000000 1000

# --------------------------------------------------
# Test 2 : ORR (1100) - Logique
# 0 | 0x80000000 = 0x80000000 (Négatif)
# Flags = 1000 (N=1, Z=0, C=0, V=0)
00000000000000000000000000000000 10000000000000000000000000000000 00000 0 1100 10000000000000000000000000000000 1000

# --------------------------------------------------
# Test 3 : MVN (1111) - Logique (NOT A)
# NOT 0 = -1 (0xFFFFFFFF)
# Flags = 1000 (N=1, Z=0, C=0, V=0)
00000000000000000000000000000000 00000000000000000000000000000000 00000 0 1111 11111111111111111111111111111111 1000

# --------------------------------------------------
# Test 4 : LSL 1 (0010) - Décalage Gauche B << 1
# B=0x80000000. Bit sortant = 1. Résultat = 0.
# Flags = 0110 (N=0, Z=1, C=1, V=0)
00000000000000000000000000000000 10000000000000000000000000000000 00001 0 0010 00000000000000000000000000000000 0110

# --------------------------------------------------
# Test 5 : LSR 1 (0011) - Décalage Droite B >> 1
# B=1. Bit sortant = 1. Résultat = 0.
# Flags = 0110 (N=0, Z=1, C=1, V=0)
00000000000000000000000000000000 00000000000000000000000000000001 00001 0 0011 00000000000000000000000000000000 0110

# --------------------------------------------------
# Test 6 : ROR 1 (0111) - Rotation Droite
# B=1. Le bit 0 devient le bit 31.
# Carry = Bit 31 du résultat = 1. Résultat Négatif.
# Flags = 1010 (N=1, Z=0, C=1, V=0)
00000000000000000000000000000000 00000000000000000000000000000001 00001 0 0111 10000000000000000000000000000000 1010

# --------------------------------------------------
# Test 7 : ADC Simple (0101) - Cin=0
# 1 + 2 = 3.
# Flags = 0000
00000000000000000000000000000001 00000000000000000000000000000010 00000 0 0101 00000000000000000000000000000011 0000

# --------------------------------------------------
# Test 8 : ADC Carry Out (0101) - Cin=0
# MaxUInt + 1 = 0.
# Flags = 0110 (N=0, Z=1, C=1, V=0)
11111111111111111111111111111111 00000000000000000000000000000001 00000 0 0101 00000000000000000000000000000000 0110

# --------------------------------------------------
# Test 9 : ADC Overflow Signé (0101) - Cin=0
# MaxPos + 1 = MinNeg (0x80000000).
# Flags = 1001 (N=1, Z=0, C=0, V=1)
01111111111111111111111111111111 00000000000000000000000000000001 00000 0 0101 10000000000000000000000000000000 1001

# --------------------------------------------------
# Test 10 : ADC avec Retenue (0101) - Cin=1
# 1 + 1 + 1 = 3.
# Flags = 0000
00000000000000000000000000000001 00000000000000000000000000000001 00000 1 0101 00000000000000000000000000000011 0000

# --------------------------------------------------
# Test 11 : CMP Egalité (1010) - B - A
# 5 - 5 = 0. Pas d'emprunt (5>=5), donc Carry=1.
# Flags = 0110 (N=0, Z=1, C=1, V=0)
00000000000000000000000000000101 00000000000000000000000000000101 00000 0 1010 00000000000000000000000000000000 0110

# --------------------------------------------------
# Test 12 : CMP Positif (1010) - B - A
# 10 - 5 = 5. Pas d'emprunt (10>=5), donc Carry=1.
# Flags = 0010 (N=0, Z=0, C=1, V=0)
00000000000000000000000000000101 00000000000000000000000000001010 00000 0 1010 00000000000000000000000000000101 0010

# --------------------------------------------------
# Test 13 : CMP Négatif (1010) - B - A
# 5 - 10 = -5. Emprunt nécessaire, donc Carry=0.
# Flags = 1000 (N=1, Z=0, C=0, V=0)
00000000000000000000000000001010 00000000000000000000000000000101 00000 0 1010 11111111111111111111111111111011 1000

# --------------------------------------------------
# Test 14 : CMP Overflow Signé (1010) - B - A
# MinNeg (0x80..) - 1. Neg - Pos = Pos (Overflow V=1).
# B(Min) > A(1) en non-signé ? Oui, donc C=1.
# Flags = 0011 (N=0, Z=0, C=1, V=1)
00000000000000000000000000000001 10000000000000000000000000000000 00000 0 1010 01111111111111111111111111111111 0011

# --------------------------------------------------
# Test 15 : RSB (1001) - 0 - A
# 0 - 1 = -1. Emprunt nécessaire, donc Carry=0.
# Flags = 1000 (N=1, Z=0, C=0, V=0)
00000000000000000000000000000001 00000000000000000000000000000000 00000 0 1001 11111111111111111111111111111111 1000

# --------------------------------------------------
# Test 16 : SBC (0110) - B - A - NOT(Cin)
# 5 - 1. On veut soustraire 0 de plus, donc Cin doit être 1 (NOT 1 = 0).
# 5 - 1 - 0 = 4. Pas d'emprunt, donc Carry=1.
# Flags = 0010 (N=0, Z=0, C=1, V=0)
00000000000000000000000000000001 00000000000000000000000000000101 00000 1 0110 00000000000000000000000000000100 0010

# --------------------------------------------------
# Test 17 : ADD Zéro (0101)
# 0 + 0 = 0.
# Flags = 0100 (N=0, Z=1, C=0, V=0)
00000000000000000000000000000000 00000000000000000000000000000000 00000 0 0101 00000000000000000000000000000000 0100

# --------------------------------------------------
# Test 18 : BIC (1110) - B AND NOT A
# B=0xF (1111), A=0x3 (0011). NOT A = 1100.
# 1111 & 1100 = 1100 (0xC).
# Flags = 0000
00000000000000000000000000000011 00000000000000000000000000001111 00000 0 1110 00000000000000000000000000001100 0000

# --------------------------------------------------
# Test 19 : MUL (1101) - A * B
# 3 * 2 = 6. Flags dépendent implémentation (souvent Z/N ok).
# Flags = 0000
00000000000000000000000000000011 00000000000000000000000000000010 00000 0 1101 00000000000000000000000000000110 0000

# --------------------------------------------------
# Test 20 : TST (1000) - A AND B (Flags seulement)
# 1 & 1 = 1. Non nul (Z=0).
# Flags = 0000
00000000000000000000000000000001 00000000000000000000000000000001 00000 0 1000 00000000000000000000000000000001 0000